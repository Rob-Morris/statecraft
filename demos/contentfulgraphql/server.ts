import * as fs from 'fs'
import http from 'http'
import express from 'express'
import * as gql from 'graphql'
import * as gqlTools from 'graphql-tools'

import * as I from '../../lib/interfaces'
import createContentful from '../../lib/stores/contentful';
import kvMem from '../../lib/stores/kvmem'
import gqlmr, {Ctx} from '../../lib/stores/graphqlmapreduce'
import augment from '../../lib/augment'
import sel from '../../lib/sel'
import subValues from '../../lib/subvalues';
import {Console} from 'console'

import Post from './post'
import {renderToString} from 'react-dom/server'
import fresh from 'fresh'
import { vRangeFrom } from '../../lib/version';


process.on('unhandledRejection', err => {
  console.error(err.stack)
  process.exit(1)
})

global.console = new (Console as any)({
  stdout: process.stdout,
  stderr: process.stderr,
  inspectOptions: {depth: null}
})

// Eventually this will be autogenerated from the schema.
const schema = gqlTools.makeExecutableSchema({
  typeDefs: `
    type Post {
      title: String,
      content: String,
      author: Author!,
      slug: [String!],
      updatedAt: String,
    }

    type Author {
      fullName: String,
    }

    type Query {
      postById(id: String!): Post
      foo: String,

      selfPost: Post,
      selfAuthor: Author,
    }
  `,
  resolvers: {
    Post: {
      author: (post, args, {txn}: Ctx) => (
        txn.get('author/' + post.author)
      )
    },

    Query: {
      postById: (_, {id}: {id: string}, {txn}: Ctx) => (
        txn.get('post/' + id)
      ),

      selfPost: (_self, _args, {Post}) => Post,
    }
  }
})

const genEtag = (versions: I.FullVersion): string => {
  const sources = Object.keys(versions).sort()
  return sources.map(s => `${s}-${Buffer.from(versions[s]).toString('base64')}`).join('_')
}

;(async () => {
  const keys = JSON.parse(fs.readFileSync('keys.json', 'utf8'))
  const ops = createContentful({
    space: keys.space,
    accessToken: keys.contentAPI,

  })

  // Ideally this wouldn't return until after we get the initial sync. This is a NYI in the contentful server.
  const cfstore = augment(await kvMem(undefined, {inner: ops}))

  ;(async () => {
    const sub = cfstore.subscribe({type: 'allkv', q: true})
    // const sub = cfstore.subscribe({type: 'static range', q: [{
    //   low: sel('post/'),
    //   high: sel('post/\xff'),
    // }]})
    for await (const r of subValues('kv', sub)) {
      console.log('results', r)
    }
  })()

  const store = await gqlmr(cfstore, {
    schema,
    mapReduces: [
      {
        type: 'Post',
        queryStr: `{selfPost {updatedAt, title, content, slug, author {fullName}}}`,
        reduce: ({selfPost}) => (
          renderToString(Post(selfPost))
        ),
        getOutputKey: (k, {selfPost}) => (`${selfPost.slug[0]}`)
      }
    ],
    prefixForCollection: new Map([
      // This is mapping graphql types -> backend key prefixes.
      ['Post', 'post/'],
      ['Author', 'author/'],
    ]),
  })

  // ;(async () => {
  //   const sub = store.subscribe({type: 'allkv', q:true})
  //   for await (const upd of subValues('kv', sub)) {
  //     console.log('sub', upd)
  //   }
  // })()

  const app = express()
  app.use(express.static(`${__dirname}/public`))

  app.get('/post/:slug', async (req, res, next) => {
    const r = await store.fetch({type: 'kv', q: new Set([req.params.slug])})
    const data = r.results.get(req.params.slug)
    if (data == null) return next()
    else {
      // TODO: ETag, etc.
      const headers = {
        'content-type': 'text/html',
        'etag': genEtag(vRangeFrom(r.versions)),
      }
      if (fresh(req.headers, headers)) return res.sendStatus(304)

      res.set(headers)
      res.send(`<!doctype html>
${data}
`)
    }
  })

  const server = http.createServer(app)
  const port = process.env['PORT'] || 2004
  server.listen(port, () => {
    console.log('listening on port', port)
  })

  // await new Promise(resolve => setTimeout(resolve, 1000))
  // const v = await store.fetch({type: 'allkv', q:true})
  // console.log('v results', v.results)

  // await backend.mutate('kv', new Map([['authors/auth', {type: 'set', data:{fullName: 'rob'}}]]))

})()